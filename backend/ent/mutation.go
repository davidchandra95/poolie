// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/slowtyper/poolie/backend/ent/booking"
	"github.com/slowtyper/poolie/backend/ent/predicate"
	"github.com/slowtyper/poolie/backend/ent/ride"
	"github.com/slowtyper/poolie/backend/ent/user"
	"github.com/slowtyper/poolie/backend/ent/vehicle"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBooking = "Booking"
	TypeRide    = "Ride"
	TypeUser    = "User"
	TypeVehicle = "Vehicle"
)

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	status                  *string
	passenger_count         *int
	addpassenger_count      *int
	total_price_amount      *int64
	addtotal_price_amount   *int64
	total_price_currency    *string
	message                 *string
	driver_response_message *string
	created_at              *time.Time
	responded_at            *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	ride                    *string
	clearedride             bool
	passenger               *string
	clearedpassenger        bool
	done                    bool
	oldValue                func(context.Context) (*Booking, error)
	predicates              []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id string) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Booking entities.
func (m *BookingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRideID sets the "ride_id" field.
func (m *BookingMutation) SetRideID(s string) {
	m.ride = &s
}

// RideID returns the value of the "ride_id" field in the mutation.
func (m *BookingMutation) RideID() (r string, exists bool) {
	v := m.ride
	if v == nil {
		return
	}
	return *v, true
}

// OldRideID returns the old "ride_id" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldRideID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRideID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRideID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRideID: %w", err)
	}
	return oldValue.RideID, nil
}

// ResetRideID resets all changes to the "ride_id" field.
func (m *BookingMutation) ResetRideID() {
	m.ride = nil
}

// SetPassengerID sets the "passenger_id" field.
func (m *BookingMutation) SetPassengerID(s string) {
	m.passenger = &s
}

// PassengerID returns the value of the "passenger_id" field in the mutation.
func (m *BookingMutation) PassengerID() (r string, exists bool) {
	v := m.passenger
	if v == nil {
		return
	}
	return *v, true
}

// OldPassengerID returns the old "passenger_id" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldPassengerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassengerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassengerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassengerID: %w", err)
	}
	return oldValue.PassengerID, nil
}

// ResetPassengerID resets all changes to the "passenger_id" field.
func (m *BookingMutation) ResetPassengerID() {
	m.passenger = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// SetPassengerCount sets the "passenger_count" field.
func (m *BookingMutation) SetPassengerCount(i int) {
	m.passenger_count = &i
	m.addpassenger_count = nil
}

// PassengerCount returns the value of the "passenger_count" field in the mutation.
func (m *BookingMutation) PassengerCount() (r int, exists bool) {
	v := m.passenger_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPassengerCount returns the old "passenger_count" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldPassengerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassengerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassengerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassengerCount: %w", err)
	}
	return oldValue.PassengerCount, nil
}

// AddPassengerCount adds i to the "passenger_count" field.
func (m *BookingMutation) AddPassengerCount(i int) {
	if m.addpassenger_count != nil {
		*m.addpassenger_count += i
	} else {
		m.addpassenger_count = &i
	}
}

// AddedPassengerCount returns the value that was added to the "passenger_count" field in this mutation.
func (m *BookingMutation) AddedPassengerCount() (r int, exists bool) {
	v := m.addpassenger_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassengerCount resets all changes to the "passenger_count" field.
func (m *BookingMutation) ResetPassengerCount() {
	m.passenger_count = nil
	m.addpassenger_count = nil
}

// SetTotalPriceAmount sets the "total_price_amount" field.
func (m *BookingMutation) SetTotalPriceAmount(i int64) {
	m.total_price_amount = &i
	m.addtotal_price_amount = nil
}

// TotalPriceAmount returns the value of the "total_price_amount" field in the mutation.
func (m *BookingMutation) TotalPriceAmount() (r int64, exists bool) {
	v := m.total_price_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPriceAmount returns the old "total_price_amount" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldTotalPriceAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPriceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPriceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPriceAmount: %w", err)
	}
	return oldValue.TotalPriceAmount, nil
}

// AddTotalPriceAmount adds i to the "total_price_amount" field.
func (m *BookingMutation) AddTotalPriceAmount(i int64) {
	if m.addtotal_price_amount != nil {
		*m.addtotal_price_amount += i
	} else {
		m.addtotal_price_amount = &i
	}
}

// AddedTotalPriceAmount returns the value that was added to the "total_price_amount" field in this mutation.
func (m *BookingMutation) AddedTotalPriceAmount() (r int64, exists bool) {
	v := m.addtotal_price_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPriceAmount resets all changes to the "total_price_amount" field.
func (m *BookingMutation) ResetTotalPriceAmount() {
	m.total_price_amount = nil
	m.addtotal_price_amount = nil
}

// SetTotalPriceCurrency sets the "total_price_currency" field.
func (m *BookingMutation) SetTotalPriceCurrency(s string) {
	m.total_price_currency = &s
}

// TotalPriceCurrency returns the value of the "total_price_currency" field in the mutation.
func (m *BookingMutation) TotalPriceCurrency() (r string, exists bool) {
	v := m.total_price_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPriceCurrency returns the old "total_price_currency" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldTotalPriceCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPriceCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPriceCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPriceCurrency: %w", err)
	}
	return oldValue.TotalPriceCurrency, nil
}

// ResetTotalPriceCurrency resets all changes to the "total_price_currency" field.
func (m *BookingMutation) ResetTotalPriceCurrency() {
	m.total_price_currency = nil
}

// SetMessage sets the "message" field.
func (m *BookingMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BookingMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *BookingMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[booking.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *BookingMutation) MessageCleared() bool {
	_, ok := m.clearedFields[booking.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *BookingMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, booking.FieldMessage)
}

// SetDriverResponseMessage sets the "driver_response_message" field.
func (m *BookingMutation) SetDriverResponseMessage(s string) {
	m.driver_response_message = &s
}

// DriverResponseMessage returns the value of the "driver_response_message" field in the mutation.
func (m *BookingMutation) DriverResponseMessage() (r string, exists bool) {
	v := m.driver_response_message
	if v == nil {
		return
	}
	return *v, true
}

// OldDriverResponseMessage returns the old "driver_response_message" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldDriverResponseMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDriverResponseMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDriverResponseMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDriverResponseMessage: %w", err)
	}
	return oldValue.DriverResponseMessage, nil
}

// ClearDriverResponseMessage clears the value of the "driver_response_message" field.
func (m *BookingMutation) ClearDriverResponseMessage() {
	m.driver_response_message = nil
	m.clearedFields[booking.FieldDriverResponseMessage] = struct{}{}
}

// DriverResponseMessageCleared returns if the "driver_response_message" field was cleared in this mutation.
func (m *BookingMutation) DriverResponseMessageCleared() bool {
	_, ok := m.clearedFields[booking.FieldDriverResponseMessage]
	return ok
}

// ResetDriverResponseMessage resets all changes to the "driver_response_message" field.
func (m *BookingMutation) ResetDriverResponseMessage() {
	m.driver_response_message = nil
	delete(m.clearedFields, booking.FieldDriverResponseMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *BookingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRespondedAt sets the "responded_at" field.
func (m *BookingMutation) SetRespondedAt(t time.Time) {
	m.responded_at = &t
}

// RespondedAt returns the value of the "responded_at" field in the mutation.
func (m *BookingMutation) RespondedAt() (r time.Time, exists bool) {
	v := m.responded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRespondedAt returns the old "responded_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldRespondedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespondedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespondedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespondedAt: %w", err)
	}
	return oldValue.RespondedAt, nil
}

// ClearRespondedAt clears the value of the "responded_at" field.
func (m *BookingMutation) ClearRespondedAt() {
	m.responded_at = nil
	m.clearedFields[booking.FieldRespondedAt] = struct{}{}
}

// RespondedAtCleared returns if the "responded_at" field was cleared in this mutation.
func (m *BookingMutation) RespondedAtCleared() bool {
	_, ok := m.clearedFields[booking.FieldRespondedAt]
	return ok
}

// ResetRespondedAt resets all changes to the "responded_at" field.
func (m *BookingMutation) ResetRespondedAt() {
	m.responded_at = nil
	delete(m.clearedFields, booking.FieldRespondedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearRide clears the "ride" edge to the Ride entity.
func (m *BookingMutation) ClearRide() {
	m.clearedride = true
	m.clearedFields[booking.FieldRideID] = struct{}{}
}

// RideCleared reports if the "ride" edge to the Ride entity was cleared.
func (m *BookingMutation) RideCleared() bool {
	return m.clearedride
}

// RideIDs returns the "ride" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RideID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) RideIDs() (ids []string) {
	if id := m.ride; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRide resets all changes to the "ride" edge.
func (m *BookingMutation) ResetRide() {
	m.ride = nil
	m.clearedride = false
}

// ClearPassenger clears the "passenger" edge to the User entity.
func (m *BookingMutation) ClearPassenger() {
	m.clearedpassenger = true
	m.clearedFields[booking.FieldPassengerID] = struct{}{}
}

// PassengerCleared reports if the "passenger" edge to the User entity was cleared.
func (m *BookingMutation) PassengerCleared() bool {
	return m.clearedpassenger
}

// PassengerIDs returns the "passenger" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PassengerID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) PassengerIDs() (ids []string) {
	if id := m.passenger; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassenger resets all changes to the "passenger" edge.
func (m *BookingMutation) ResetPassenger() {
	m.passenger = nil
	m.clearedpassenger = false
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.ride != nil {
		fields = append(fields, booking.FieldRideID)
	}
	if m.passenger != nil {
		fields = append(fields, booking.FieldPassengerID)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	if m.passenger_count != nil {
		fields = append(fields, booking.FieldPassengerCount)
	}
	if m.total_price_amount != nil {
		fields = append(fields, booking.FieldTotalPriceAmount)
	}
	if m.total_price_currency != nil {
		fields = append(fields, booking.FieldTotalPriceCurrency)
	}
	if m.message != nil {
		fields = append(fields, booking.FieldMessage)
	}
	if m.driver_response_message != nil {
		fields = append(fields, booking.FieldDriverResponseMessage)
	}
	if m.created_at != nil {
		fields = append(fields, booking.FieldCreatedAt)
	}
	if m.responded_at != nil {
		fields = append(fields, booking.FieldRespondedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, booking.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldRideID:
		return m.RideID()
	case booking.FieldPassengerID:
		return m.PassengerID()
	case booking.FieldStatus:
		return m.Status()
	case booking.FieldPassengerCount:
		return m.PassengerCount()
	case booking.FieldTotalPriceAmount:
		return m.TotalPriceAmount()
	case booking.FieldTotalPriceCurrency:
		return m.TotalPriceCurrency()
	case booking.FieldMessage:
		return m.Message()
	case booking.FieldDriverResponseMessage:
		return m.DriverResponseMessage()
	case booking.FieldCreatedAt:
		return m.CreatedAt()
	case booking.FieldRespondedAt:
		return m.RespondedAt()
	case booking.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldRideID:
		return m.OldRideID(ctx)
	case booking.FieldPassengerID:
		return m.OldPassengerID(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	case booking.FieldPassengerCount:
		return m.OldPassengerCount(ctx)
	case booking.FieldTotalPriceAmount:
		return m.OldTotalPriceAmount(ctx)
	case booking.FieldTotalPriceCurrency:
		return m.OldTotalPriceCurrency(ctx)
	case booking.FieldMessage:
		return m.OldMessage(ctx)
	case booking.FieldDriverResponseMessage:
		return m.OldDriverResponseMessage(ctx)
	case booking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case booking.FieldRespondedAt:
		return m.OldRespondedAt(ctx)
	case booking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldRideID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRideID(v)
		return nil
	case booking.FieldPassengerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassengerID(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case booking.FieldPassengerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassengerCount(v)
		return nil
	case booking.FieldTotalPriceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPriceAmount(v)
		return nil
	case booking.FieldTotalPriceCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPriceCurrency(v)
		return nil
	case booking.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case booking.FieldDriverResponseMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDriverResponseMessage(v)
		return nil
	case booking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case booking.FieldRespondedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespondedAt(v)
		return nil
	case booking.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	var fields []string
	if m.addpassenger_count != nil {
		fields = append(fields, booking.FieldPassengerCount)
	}
	if m.addtotal_price_amount != nil {
		fields = append(fields, booking.FieldTotalPriceAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldPassengerCount:
		return m.AddedPassengerCount()
	case booking.FieldTotalPriceAmount:
		return m.AddedTotalPriceAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case booking.FieldPassengerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassengerCount(v)
		return nil
	case booking.FieldTotalPriceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPriceAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(booking.FieldMessage) {
		fields = append(fields, booking.FieldMessage)
	}
	if m.FieldCleared(booking.FieldDriverResponseMessage) {
		fields = append(fields, booking.FieldDriverResponseMessage)
	}
	if m.FieldCleared(booking.FieldRespondedAt) {
		fields = append(fields, booking.FieldRespondedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	switch name {
	case booking.FieldMessage:
		m.ClearMessage()
		return nil
	case booking.FieldDriverResponseMessage:
		m.ClearDriverResponseMessage()
		return nil
	case booking.FieldRespondedAt:
		m.ClearRespondedAt()
		return nil
	}
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldRideID:
		m.ResetRideID()
		return nil
	case booking.FieldPassengerID:
		m.ResetPassengerID()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	case booking.FieldPassengerCount:
		m.ResetPassengerCount()
		return nil
	case booking.FieldTotalPriceAmount:
		m.ResetTotalPriceAmount()
		return nil
	case booking.FieldTotalPriceCurrency:
		m.ResetTotalPriceCurrency()
		return nil
	case booking.FieldMessage:
		m.ResetMessage()
		return nil
	case booking.FieldDriverResponseMessage:
		m.ResetDriverResponseMessage()
		return nil
	case booking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case booking.FieldRespondedAt:
		m.ResetRespondedAt()
		return nil
	case booking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ride != nil {
		edges = append(edges, booking.EdgeRide)
	}
	if m.passenger != nil {
		edges = append(edges, booking.EdgePassenger)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeRide:
		if id := m.ride; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgePassenger:
		if id := m.passenger; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedride {
		edges = append(edges, booking.EdgeRide)
	}
	if m.clearedpassenger {
		edges = append(edges, booking.EdgePassenger)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeRide:
		return m.clearedride
	case booking.EdgePassenger:
		return m.clearedpassenger
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeRide:
		m.ClearRide()
		return nil
	case booking.EdgePassenger:
		m.ClearPassenger()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeRide:
		m.ResetRide()
		return nil
	case booking.EdgePassenger:
		m.ResetPassenger()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// RideMutation represents an operation that mutates the Ride nodes in the graph.
type RideMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	_type                      *string
	ride_type                  *string
	recurrence                 *map[string]interface{}
	departure_time             *time.Time
	arrival_time               *time.Time
	duration_minutes           *int
	addduration_minutes        *int
	origin_city                *string
	origin_address             *string
	origin_location_point      *string
	destination_city           *string
	destination_address        *string
	destination_location_point *string
	price_amount               *int64
	addprice_amount            *int64
	price_currency             *string
	available_seats            *int
	addavailable_seats         *int
	total_seats                *int
	addtotal_seats             *int
	amenities                  *map[string]interface{}
	stops                      *[]interface{}
	appendstops                []interface{}
	instant_confirmation       *bool
	cancellation_policy        *string
	description                *string
	status                     *string
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	_driver                    *string
	cleared_driver             bool
	vehicle                    *string
	clearedvehicle             bool
	bookings                   map[string]struct{}
	removedbookings            map[string]struct{}
	clearedbookings            bool
	done                       bool
	oldValue                   func(context.Context) (*Ride, error)
	predicates                 []predicate.Ride
}

var _ ent.Mutation = (*RideMutation)(nil)

// rideOption allows management of the mutation configuration using functional options.
type rideOption func(*RideMutation)

// newRideMutation creates new mutation for the Ride entity.
func newRideMutation(c config, op Op, opts ...rideOption) *RideMutation {
	m := &RideMutation{
		config:        c,
		op:            op,
		typ:           TypeRide,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRideID sets the ID field of the mutation.
func withRideID(id string) rideOption {
	return func(m *RideMutation) {
		var (
			err   error
			once  sync.Once
			value *Ride
		)
		m.oldValue = func(ctx context.Context) (*Ride, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ride.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRide sets the old Ride of the mutation.
func withRide(node *Ride) rideOption {
	return func(m *RideMutation) {
		m.oldValue = func(context.Context) (*Ride, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ride entities.
func (m *RideMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RideMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RideMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ride.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDriverID sets the "driver_id" field.
func (m *RideMutation) SetDriverID(s string) {
	m._driver = &s
}

// DriverID returns the value of the "driver_id" field in the mutation.
func (m *RideMutation) DriverID() (r string, exists bool) {
	v := m._driver
	if v == nil {
		return
	}
	return *v, true
}

// OldDriverID returns the old "driver_id" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDriverID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDriverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDriverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDriverID: %w", err)
	}
	return oldValue.DriverID, nil
}

// ResetDriverID resets all changes to the "driver_id" field.
func (m *RideMutation) ResetDriverID() {
	m._driver = nil
}

// SetVehicleID sets the "vehicle_id" field.
func (m *RideMutation) SetVehicleID(s string) {
	m.vehicle = &s
}

// VehicleID returns the value of the "vehicle_id" field in the mutation.
func (m *RideMutation) VehicleID() (r string, exists bool) {
	v := m.vehicle
	if v == nil {
		return
	}
	return *v, true
}

// OldVehicleID returns the old "vehicle_id" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldVehicleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVehicleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVehicleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVehicleID: %w", err)
	}
	return oldValue.VehicleID, nil
}

// ClearVehicleID clears the value of the "vehicle_id" field.
func (m *RideMutation) ClearVehicleID() {
	m.vehicle = nil
	m.clearedFields[ride.FieldVehicleID] = struct{}{}
}

// VehicleIDCleared returns if the "vehicle_id" field was cleared in this mutation.
func (m *RideMutation) VehicleIDCleared() bool {
	_, ok := m.clearedFields[ride.FieldVehicleID]
	return ok
}

// ResetVehicleID resets all changes to the "vehicle_id" field.
func (m *RideMutation) ResetVehicleID() {
	m.vehicle = nil
	delete(m.clearedFields, ride.FieldVehicleID)
}

// SetType sets the "type" field.
func (m *RideMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RideMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RideMutation) ResetType() {
	m._type = nil
}

// SetRideType sets the "ride_type" field.
func (m *RideMutation) SetRideType(s string) {
	m.ride_type = &s
}

// RideType returns the value of the "ride_type" field in the mutation.
func (m *RideMutation) RideType() (r string, exists bool) {
	v := m.ride_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRideType returns the old "ride_type" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldRideType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRideType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRideType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRideType: %w", err)
	}
	return oldValue.RideType, nil
}

// ResetRideType resets all changes to the "ride_type" field.
func (m *RideMutation) ResetRideType() {
	m.ride_type = nil
}

// SetRecurrence sets the "recurrence" field.
func (m *RideMutation) SetRecurrence(value map[string]interface{}) {
	m.recurrence = &value
}

// Recurrence returns the value of the "recurrence" field in the mutation.
func (m *RideMutation) Recurrence() (r map[string]interface{}, exists bool) {
	v := m.recurrence
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrence returns the old "recurrence" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldRecurrence(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurrence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurrence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrence: %w", err)
	}
	return oldValue.Recurrence, nil
}

// ClearRecurrence clears the value of the "recurrence" field.
func (m *RideMutation) ClearRecurrence() {
	m.recurrence = nil
	m.clearedFields[ride.FieldRecurrence] = struct{}{}
}

// RecurrenceCleared returns if the "recurrence" field was cleared in this mutation.
func (m *RideMutation) RecurrenceCleared() bool {
	_, ok := m.clearedFields[ride.FieldRecurrence]
	return ok
}

// ResetRecurrence resets all changes to the "recurrence" field.
func (m *RideMutation) ResetRecurrence() {
	m.recurrence = nil
	delete(m.clearedFields, ride.FieldRecurrence)
}

// SetDepartureTime sets the "departure_time" field.
func (m *RideMutation) SetDepartureTime(t time.Time) {
	m.departure_time = &t
}

// DepartureTime returns the value of the "departure_time" field in the mutation.
func (m *RideMutation) DepartureTime() (r time.Time, exists bool) {
	v := m.departure_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureTime returns the old "departure_time" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDepartureTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureTime: %w", err)
	}
	return oldValue.DepartureTime, nil
}

// ResetDepartureTime resets all changes to the "departure_time" field.
func (m *RideMutation) ResetDepartureTime() {
	m.departure_time = nil
}

// SetArrivalTime sets the "arrival_time" field.
func (m *RideMutation) SetArrivalTime(t time.Time) {
	m.arrival_time = &t
}

// ArrivalTime returns the value of the "arrival_time" field in the mutation.
func (m *RideMutation) ArrivalTime() (r time.Time, exists bool) {
	v := m.arrival_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivalTime returns the old "arrival_time" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldArrivalTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivalTime: %w", err)
	}
	return oldValue.ArrivalTime, nil
}

// ClearArrivalTime clears the value of the "arrival_time" field.
func (m *RideMutation) ClearArrivalTime() {
	m.arrival_time = nil
	m.clearedFields[ride.FieldArrivalTime] = struct{}{}
}

// ArrivalTimeCleared returns if the "arrival_time" field was cleared in this mutation.
func (m *RideMutation) ArrivalTimeCleared() bool {
	_, ok := m.clearedFields[ride.FieldArrivalTime]
	return ok
}

// ResetArrivalTime resets all changes to the "arrival_time" field.
func (m *RideMutation) ResetArrivalTime() {
	m.arrival_time = nil
	delete(m.clearedFields, ride.FieldArrivalTime)
}

// SetDurationMinutes sets the "duration_minutes" field.
func (m *RideMutation) SetDurationMinutes(i int) {
	m.duration_minutes = &i
	m.addduration_minutes = nil
}

// DurationMinutes returns the value of the "duration_minutes" field in the mutation.
func (m *RideMutation) DurationMinutes() (r int, exists bool) {
	v := m.duration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMinutes returns the old "duration_minutes" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDurationMinutes(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMinutes: %w", err)
	}
	return oldValue.DurationMinutes, nil
}

// AddDurationMinutes adds i to the "duration_minutes" field.
func (m *RideMutation) AddDurationMinutes(i int) {
	if m.addduration_minutes != nil {
		*m.addduration_minutes += i
	} else {
		m.addduration_minutes = &i
	}
}

// AddedDurationMinutes returns the value that was added to the "duration_minutes" field in this mutation.
func (m *RideMutation) AddedDurationMinutes() (r int, exists bool) {
	v := m.addduration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMinutes clears the value of the "duration_minutes" field.
func (m *RideMutation) ClearDurationMinutes() {
	m.duration_minutes = nil
	m.addduration_minutes = nil
	m.clearedFields[ride.FieldDurationMinutes] = struct{}{}
}

// DurationMinutesCleared returns if the "duration_minutes" field was cleared in this mutation.
func (m *RideMutation) DurationMinutesCleared() bool {
	_, ok := m.clearedFields[ride.FieldDurationMinutes]
	return ok
}

// ResetDurationMinutes resets all changes to the "duration_minutes" field.
func (m *RideMutation) ResetDurationMinutes() {
	m.duration_minutes = nil
	m.addduration_minutes = nil
	delete(m.clearedFields, ride.FieldDurationMinutes)
}

// SetOriginCity sets the "origin_city" field.
func (m *RideMutation) SetOriginCity(s string) {
	m.origin_city = &s
}

// OriginCity returns the value of the "origin_city" field in the mutation.
func (m *RideMutation) OriginCity() (r string, exists bool) {
	v := m.origin_city
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginCity returns the old "origin_city" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldOriginCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginCity: %w", err)
	}
	return oldValue.OriginCity, nil
}

// ResetOriginCity resets all changes to the "origin_city" field.
func (m *RideMutation) ResetOriginCity() {
	m.origin_city = nil
}

// SetOriginAddress sets the "origin_address" field.
func (m *RideMutation) SetOriginAddress(s string) {
	m.origin_address = &s
}

// OriginAddress returns the value of the "origin_address" field in the mutation.
func (m *RideMutation) OriginAddress() (r string, exists bool) {
	v := m.origin_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginAddress returns the old "origin_address" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldOriginAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginAddress: %w", err)
	}
	return oldValue.OriginAddress, nil
}

// ResetOriginAddress resets all changes to the "origin_address" field.
func (m *RideMutation) ResetOriginAddress() {
	m.origin_address = nil
}

// SetOriginLocationPoint sets the "origin_location_point" field.
func (m *RideMutation) SetOriginLocationPoint(s string) {
	m.origin_location_point = &s
}

// OriginLocationPoint returns the value of the "origin_location_point" field in the mutation.
func (m *RideMutation) OriginLocationPoint() (r string, exists bool) {
	v := m.origin_location_point
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginLocationPoint returns the old "origin_location_point" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldOriginLocationPoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginLocationPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginLocationPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginLocationPoint: %w", err)
	}
	return oldValue.OriginLocationPoint, nil
}

// ClearOriginLocationPoint clears the value of the "origin_location_point" field.
func (m *RideMutation) ClearOriginLocationPoint() {
	m.origin_location_point = nil
	m.clearedFields[ride.FieldOriginLocationPoint] = struct{}{}
}

// OriginLocationPointCleared returns if the "origin_location_point" field was cleared in this mutation.
func (m *RideMutation) OriginLocationPointCleared() bool {
	_, ok := m.clearedFields[ride.FieldOriginLocationPoint]
	return ok
}

// ResetOriginLocationPoint resets all changes to the "origin_location_point" field.
func (m *RideMutation) ResetOriginLocationPoint() {
	m.origin_location_point = nil
	delete(m.clearedFields, ride.FieldOriginLocationPoint)
}

// SetDestinationCity sets the "destination_city" field.
func (m *RideMutation) SetDestinationCity(s string) {
	m.destination_city = &s
}

// DestinationCity returns the value of the "destination_city" field in the mutation.
func (m *RideMutation) DestinationCity() (r string, exists bool) {
	v := m.destination_city
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationCity returns the old "destination_city" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDestinationCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationCity: %w", err)
	}
	return oldValue.DestinationCity, nil
}

// ResetDestinationCity resets all changes to the "destination_city" field.
func (m *RideMutation) ResetDestinationCity() {
	m.destination_city = nil
}

// SetDestinationAddress sets the "destination_address" field.
func (m *RideMutation) SetDestinationAddress(s string) {
	m.destination_address = &s
}

// DestinationAddress returns the value of the "destination_address" field in the mutation.
func (m *RideMutation) DestinationAddress() (r string, exists bool) {
	v := m.destination_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationAddress returns the old "destination_address" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDestinationAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationAddress: %w", err)
	}
	return oldValue.DestinationAddress, nil
}

// ResetDestinationAddress resets all changes to the "destination_address" field.
func (m *RideMutation) ResetDestinationAddress() {
	m.destination_address = nil
}

// SetDestinationLocationPoint sets the "destination_location_point" field.
func (m *RideMutation) SetDestinationLocationPoint(s string) {
	m.destination_location_point = &s
}

// DestinationLocationPoint returns the value of the "destination_location_point" field in the mutation.
func (m *RideMutation) DestinationLocationPoint() (r string, exists bool) {
	v := m.destination_location_point
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationLocationPoint returns the old "destination_location_point" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDestinationLocationPoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationLocationPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationLocationPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationLocationPoint: %w", err)
	}
	return oldValue.DestinationLocationPoint, nil
}

// ClearDestinationLocationPoint clears the value of the "destination_location_point" field.
func (m *RideMutation) ClearDestinationLocationPoint() {
	m.destination_location_point = nil
	m.clearedFields[ride.FieldDestinationLocationPoint] = struct{}{}
}

// DestinationLocationPointCleared returns if the "destination_location_point" field was cleared in this mutation.
func (m *RideMutation) DestinationLocationPointCleared() bool {
	_, ok := m.clearedFields[ride.FieldDestinationLocationPoint]
	return ok
}

// ResetDestinationLocationPoint resets all changes to the "destination_location_point" field.
func (m *RideMutation) ResetDestinationLocationPoint() {
	m.destination_location_point = nil
	delete(m.clearedFields, ride.FieldDestinationLocationPoint)
}

// SetPriceAmount sets the "price_amount" field.
func (m *RideMutation) SetPriceAmount(i int64) {
	m.price_amount = &i
	m.addprice_amount = nil
}

// PriceAmount returns the value of the "price_amount" field in the mutation.
func (m *RideMutation) PriceAmount() (r int64, exists bool) {
	v := m.price_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceAmount returns the old "price_amount" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldPriceAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceAmount: %w", err)
	}
	return oldValue.PriceAmount, nil
}

// AddPriceAmount adds i to the "price_amount" field.
func (m *RideMutation) AddPriceAmount(i int64) {
	if m.addprice_amount != nil {
		*m.addprice_amount += i
	} else {
		m.addprice_amount = &i
	}
}

// AddedPriceAmount returns the value that was added to the "price_amount" field in this mutation.
func (m *RideMutation) AddedPriceAmount() (r int64, exists bool) {
	v := m.addprice_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceAmount resets all changes to the "price_amount" field.
func (m *RideMutation) ResetPriceAmount() {
	m.price_amount = nil
	m.addprice_amount = nil
}

// SetPriceCurrency sets the "price_currency" field.
func (m *RideMutation) SetPriceCurrency(s string) {
	m.price_currency = &s
}

// PriceCurrency returns the value of the "price_currency" field in the mutation.
func (m *RideMutation) PriceCurrency() (r string, exists bool) {
	v := m.price_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceCurrency returns the old "price_currency" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldPriceCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceCurrency: %w", err)
	}
	return oldValue.PriceCurrency, nil
}

// ResetPriceCurrency resets all changes to the "price_currency" field.
func (m *RideMutation) ResetPriceCurrency() {
	m.price_currency = nil
}

// SetAvailableSeats sets the "available_seats" field.
func (m *RideMutation) SetAvailableSeats(i int) {
	m.available_seats = &i
	m.addavailable_seats = nil
}

// AvailableSeats returns the value of the "available_seats" field in the mutation.
func (m *RideMutation) AvailableSeats() (r int, exists bool) {
	v := m.available_seats
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableSeats returns the old "available_seats" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldAvailableSeats(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableSeats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableSeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableSeats: %w", err)
	}
	return oldValue.AvailableSeats, nil
}

// AddAvailableSeats adds i to the "available_seats" field.
func (m *RideMutation) AddAvailableSeats(i int) {
	if m.addavailable_seats != nil {
		*m.addavailable_seats += i
	} else {
		m.addavailable_seats = &i
	}
}

// AddedAvailableSeats returns the value that was added to the "available_seats" field in this mutation.
func (m *RideMutation) AddedAvailableSeats() (r int, exists bool) {
	v := m.addavailable_seats
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableSeats resets all changes to the "available_seats" field.
func (m *RideMutation) ResetAvailableSeats() {
	m.available_seats = nil
	m.addavailable_seats = nil
}

// SetTotalSeats sets the "total_seats" field.
func (m *RideMutation) SetTotalSeats(i int) {
	m.total_seats = &i
	m.addtotal_seats = nil
}

// TotalSeats returns the value of the "total_seats" field in the mutation.
func (m *RideMutation) TotalSeats() (r int, exists bool) {
	v := m.total_seats
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSeats returns the old "total_seats" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldTotalSeats(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSeats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSeats: %w", err)
	}
	return oldValue.TotalSeats, nil
}

// AddTotalSeats adds i to the "total_seats" field.
func (m *RideMutation) AddTotalSeats(i int) {
	if m.addtotal_seats != nil {
		*m.addtotal_seats += i
	} else {
		m.addtotal_seats = &i
	}
}

// AddedTotalSeats returns the value that was added to the "total_seats" field in this mutation.
func (m *RideMutation) AddedTotalSeats() (r int, exists bool) {
	v := m.addtotal_seats
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSeats resets all changes to the "total_seats" field.
func (m *RideMutation) ResetTotalSeats() {
	m.total_seats = nil
	m.addtotal_seats = nil
}

// SetAmenities sets the "amenities" field.
func (m *RideMutation) SetAmenities(value map[string]interface{}) {
	m.amenities = &value
}

// Amenities returns the value of the "amenities" field in the mutation.
func (m *RideMutation) Amenities() (r map[string]interface{}, exists bool) {
	v := m.amenities
	if v == nil {
		return
	}
	return *v, true
}

// OldAmenities returns the old "amenities" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldAmenities(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmenities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmenities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmenities: %w", err)
	}
	return oldValue.Amenities, nil
}

// ClearAmenities clears the value of the "amenities" field.
func (m *RideMutation) ClearAmenities() {
	m.amenities = nil
	m.clearedFields[ride.FieldAmenities] = struct{}{}
}

// AmenitiesCleared returns if the "amenities" field was cleared in this mutation.
func (m *RideMutation) AmenitiesCleared() bool {
	_, ok := m.clearedFields[ride.FieldAmenities]
	return ok
}

// ResetAmenities resets all changes to the "amenities" field.
func (m *RideMutation) ResetAmenities() {
	m.amenities = nil
	delete(m.clearedFields, ride.FieldAmenities)
}

// SetStops sets the "stops" field.
func (m *RideMutation) SetStops(i []interface{}) {
	m.stops = &i
	m.appendstops = nil
}

// Stops returns the value of the "stops" field in the mutation.
func (m *RideMutation) Stops() (r []interface{}, exists bool) {
	v := m.stops
	if v == nil {
		return
	}
	return *v, true
}

// OldStops returns the old "stops" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldStops(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStops is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStops requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStops: %w", err)
	}
	return oldValue.Stops, nil
}

// AppendStops adds i to the "stops" field.
func (m *RideMutation) AppendStops(i []interface{}) {
	m.appendstops = append(m.appendstops, i...)
}

// AppendedStops returns the list of values that were appended to the "stops" field in this mutation.
func (m *RideMutation) AppendedStops() ([]interface{}, bool) {
	if len(m.appendstops) == 0 {
		return nil, false
	}
	return m.appendstops, true
}

// ClearStops clears the value of the "stops" field.
func (m *RideMutation) ClearStops() {
	m.stops = nil
	m.appendstops = nil
	m.clearedFields[ride.FieldStops] = struct{}{}
}

// StopsCleared returns if the "stops" field was cleared in this mutation.
func (m *RideMutation) StopsCleared() bool {
	_, ok := m.clearedFields[ride.FieldStops]
	return ok
}

// ResetStops resets all changes to the "stops" field.
func (m *RideMutation) ResetStops() {
	m.stops = nil
	m.appendstops = nil
	delete(m.clearedFields, ride.FieldStops)
}

// SetInstantConfirmation sets the "instant_confirmation" field.
func (m *RideMutation) SetInstantConfirmation(b bool) {
	m.instant_confirmation = &b
}

// InstantConfirmation returns the value of the "instant_confirmation" field in the mutation.
func (m *RideMutation) InstantConfirmation() (r bool, exists bool) {
	v := m.instant_confirmation
	if v == nil {
		return
	}
	return *v, true
}

// OldInstantConfirmation returns the old "instant_confirmation" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldInstantConfirmation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstantConfirmation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstantConfirmation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstantConfirmation: %w", err)
	}
	return oldValue.InstantConfirmation, nil
}

// ResetInstantConfirmation resets all changes to the "instant_confirmation" field.
func (m *RideMutation) ResetInstantConfirmation() {
	m.instant_confirmation = nil
}

// SetCancellationPolicy sets the "cancellation_policy" field.
func (m *RideMutation) SetCancellationPolicy(s string) {
	m.cancellation_policy = &s
}

// CancellationPolicy returns the value of the "cancellation_policy" field in the mutation.
func (m *RideMutation) CancellationPolicy() (r string, exists bool) {
	v := m.cancellation_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldCancellationPolicy returns the old "cancellation_policy" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldCancellationPolicy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancellationPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancellationPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancellationPolicy: %w", err)
	}
	return oldValue.CancellationPolicy, nil
}

// ResetCancellationPolicy resets all changes to the "cancellation_policy" field.
func (m *RideMutation) ResetCancellationPolicy() {
	m.cancellation_policy = nil
}

// SetDescription sets the "description" field.
func (m *RideMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RideMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RideMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ride.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RideMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ride.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RideMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ride.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *RideMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RideMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RideMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearDriver clears the "driver" edge to the User entity.
func (m *RideMutation) ClearDriver() {
	m.cleared_driver = true
	m.clearedFields[ride.FieldDriverID] = struct{}{}
}

// DriverCleared reports if the "driver" edge to the User entity was cleared.
func (m *RideMutation) DriverCleared() bool {
	return m.cleared_driver
}

// DriverIDs returns the "driver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DriverID instead. It exists only for internal usage by the builders.
func (m *RideMutation) DriverIDs() (ids []string) {
	if id := m._driver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDriver resets all changes to the "driver" edge.
func (m *RideMutation) ResetDriver() {
	m._driver = nil
	m.cleared_driver = false
}

// ClearVehicle clears the "vehicle" edge to the Vehicle entity.
func (m *RideMutation) ClearVehicle() {
	m.clearedvehicle = true
	m.clearedFields[ride.FieldVehicleID] = struct{}{}
}

// VehicleCleared reports if the "vehicle" edge to the Vehicle entity was cleared.
func (m *RideMutation) VehicleCleared() bool {
	return m.VehicleIDCleared() || m.clearedvehicle
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *RideMutation) VehicleIDs() (ids []string) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *RideMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *RideMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *RideMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *RideMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *RideMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *RideMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *RideMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *RideMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// Where appends a list predicates to the RideMutation builder.
func (m *RideMutation) Where(ps ...predicate.Ride) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ride, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ride).
func (m *RideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RideMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m._driver != nil {
		fields = append(fields, ride.FieldDriverID)
	}
	if m.vehicle != nil {
		fields = append(fields, ride.FieldVehicleID)
	}
	if m._type != nil {
		fields = append(fields, ride.FieldType)
	}
	if m.ride_type != nil {
		fields = append(fields, ride.FieldRideType)
	}
	if m.recurrence != nil {
		fields = append(fields, ride.FieldRecurrence)
	}
	if m.departure_time != nil {
		fields = append(fields, ride.FieldDepartureTime)
	}
	if m.arrival_time != nil {
		fields = append(fields, ride.FieldArrivalTime)
	}
	if m.duration_minutes != nil {
		fields = append(fields, ride.FieldDurationMinutes)
	}
	if m.origin_city != nil {
		fields = append(fields, ride.FieldOriginCity)
	}
	if m.origin_address != nil {
		fields = append(fields, ride.FieldOriginAddress)
	}
	if m.origin_location_point != nil {
		fields = append(fields, ride.FieldOriginLocationPoint)
	}
	if m.destination_city != nil {
		fields = append(fields, ride.FieldDestinationCity)
	}
	if m.destination_address != nil {
		fields = append(fields, ride.FieldDestinationAddress)
	}
	if m.destination_location_point != nil {
		fields = append(fields, ride.FieldDestinationLocationPoint)
	}
	if m.price_amount != nil {
		fields = append(fields, ride.FieldPriceAmount)
	}
	if m.price_currency != nil {
		fields = append(fields, ride.FieldPriceCurrency)
	}
	if m.available_seats != nil {
		fields = append(fields, ride.FieldAvailableSeats)
	}
	if m.total_seats != nil {
		fields = append(fields, ride.FieldTotalSeats)
	}
	if m.amenities != nil {
		fields = append(fields, ride.FieldAmenities)
	}
	if m.stops != nil {
		fields = append(fields, ride.FieldStops)
	}
	if m.instant_confirmation != nil {
		fields = append(fields, ride.FieldInstantConfirmation)
	}
	if m.cancellation_policy != nil {
		fields = append(fields, ride.FieldCancellationPolicy)
	}
	if m.description != nil {
		fields = append(fields, ride.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, ride.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, ride.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ride.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ride.FieldDriverID:
		return m.DriverID()
	case ride.FieldVehicleID:
		return m.VehicleID()
	case ride.FieldType:
		return m.GetType()
	case ride.FieldRideType:
		return m.RideType()
	case ride.FieldRecurrence:
		return m.Recurrence()
	case ride.FieldDepartureTime:
		return m.DepartureTime()
	case ride.FieldArrivalTime:
		return m.ArrivalTime()
	case ride.FieldDurationMinutes:
		return m.DurationMinutes()
	case ride.FieldOriginCity:
		return m.OriginCity()
	case ride.FieldOriginAddress:
		return m.OriginAddress()
	case ride.FieldOriginLocationPoint:
		return m.OriginLocationPoint()
	case ride.FieldDestinationCity:
		return m.DestinationCity()
	case ride.FieldDestinationAddress:
		return m.DestinationAddress()
	case ride.FieldDestinationLocationPoint:
		return m.DestinationLocationPoint()
	case ride.FieldPriceAmount:
		return m.PriceAmount()
	case ride.FieldPriceCurrency:
		return m.PriceCurrency()
	case ride.FieldAvailableSeats:
		return m.AvailableSeats()
	case ride.FieldTotalSeats:
		return m.TotalSeats()
	case ride.FieldAmenities:
		return m.Amenities()
	case ride.FieldStops:
		return m.Stops()
	case ride.FieldInstantConfirmation:
		return m.InstantConfirmation()
	case ride.FieldCancellationPolicy:
		return m.CancellationPolicy()
	case ride.FieldDescription:
		return m.Description()
	case ride.FieldStatus:
		return m.Status()
	case ride.FieldCreatedAt:
		return m.CreatedAt()
	case ride.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ride.FieldDriverID:
		return m.OldDriverID(ctx)
	case ride.FieldVehicleID:
		return m.OldVehicleID(ctx)
	case ride.FieldType:
		return m.OldType(ctx)
	case ride.FieldRideType:
		return m.OldRideType(ctx)
	case ride.FieldRecurrence:
		return m.OldRecurrence(ctx)
	case ride.FieldDepartureTime:
		return m.OldDepartureTime(ctx)
	case ride.FieldArrivalTime:
		return m.OldArrivalTime(ctx)
	case ride.FieldDurationMinutes:
		return m.OldDurationMinutes(ctx)
	case ride.FieldOriginCity:
		return m.OldOriginCity(ctx)
	case ride.FieldOriginAddress:
		return m.OldOriginAddress(ctx)
	case ride.FieldOriginLocationPoint:
		return m.OldOriginLocationPoint(ctx)
	case ride.FieldDestinationCity:
		return m.OldDestinationCity(ctx)
	case ride.FieldDestinationAddress:
		return m.OldDestinationAddress(ctx)
	case ride.FieldDestinationLocationPoint:
		return m.OldDestinationLocationPoint(ctx)
	case ride.FieldPriceAmount:
		return m.OldPriceAmount(ctx)
	case ride.FieldPriceCurrency:
		return m.OldPriceCurrency(ctx)
	case ride.FieldAvailableSeats:
		return m.OldAvailableSeats(ctx)
	case ride.FieldTotalSeats:
		return m.OldTotalSeats(ctx)
	case ride.FieldAmenities:
		return m.OldAmenities(ctx)
	case ride.FieldStops:
		return m.OldStops(ctx)
	case ride.FieldInstantConfirmation:
		return m.OldInstantConfirmation(ctx)
	case ride.FieldCancellationPolicy:
		return m.OldCancellationPolicy(ctx)
	case ride.FieldDescription:
		return m.OldDescription(ctx)
	case ride.FieldStatus:
		return m.OldStatus(ctx)
	case ride.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ride.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ride field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ride.FieldDriverID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDriverID(v)
		return nil
	case ride.FieldVehicleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVehicleID(v)
		return nil
	case ride.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case ride.FieldRideType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRideType(v)
		return nil
	case ride.FieldRecurrence:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrence(v)
		return nil
	case ride.FieldDepartureTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureTime(v)
		return nil
	case ride.FieldArrivalTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivalTime(v)
		return nil
	case ride.FieldDurationMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMinutes(v)
		return nil
	case ride.FieldOriginCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginCity(v)
		return nil
	case ride.FieldOriginAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginAddress(v)
		return nil
	case ride.FieldOriginLocationPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginLocationPoint(v)
		return nil
	case ride.FieldDestinationCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationCity(v)
		return nil
	case ride.FieldDestinationAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationAddress(v)
		return nil
	case ride.FieldDestinationLocationPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationLocationPoint(v)
		return nil
	case ride.FieldPriceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceAmount(v)
		return nil
	case ride.FieldPriceCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceCurrency(v)
		return nil
	case ride.FieldAvailableSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableSeats(v)
		return nil
	case ride.FieldTotalSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSeats(v)
		return nil
	case ride.FieldAmenities:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmenities(v)
		return nil
	case ride.FieldStops:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStops(v)
		return nil
	case ride.FieldInstantConfirmation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstantConfirmation(v)
		return nil
	case ride.FieldCancellationPolicy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancellationPolicy(v)
		return nil
	case ride.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ride.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ride.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ride.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ride field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RideMutation) AddedFields() []string {
	var fields []string
	if m.addduration_minutes != nil {
		fields = append(fields, ride.FieldDurationMinutes)
	}
	if m.addprice_amount != nil {
		fields = append(fields, ride.FieldPriceAmount)
	}
	if m.addavailable_seats != nil {
		fields = append(fields, ride.FieldAvailableSeats)
	}
	if m.addtotal_seats != nil {
		fields = append(fields, ride.FieldTotalSeats)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ride.FieldDurationMinutes:
		return m.AddedDurationMinutes()
	case ride.FieldPriceAmount:
		return m.AddedPriceAmount()
	case ride.FieldAvailableSeats:
		return m.AddedAvailableSeats()
	case ride.FieldTotalSeats:
		return m.AddedTotalSeats()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RideMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ride.FieldDurationMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMinutes(v)
		return nil
	case ride.FieldPriceAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceAmount(v)
		return nil
	case ride.FieldAvailableSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableSeats(v)
		return nil
	case ride.FieldTotalSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSeats(v)
		return nil
	}
	return fmt.Errorf("unknown Ride numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ride.FieldVehicleID) {
		fields = append(fields, ride.FieldVehicleID)
	}
	if m.FieldCleared(ride.FieldRecurrence) {
		fields = append(fields, ride.FieldRecurrence)
	}
	if m.FieldCleared(ride.FieldArrivalTime) {
		fields = append(fields, ride.FieldArrivalTime)
	}
	if m.FieldCleared(ride.FieldDurationMinutes) {
		fields = append(fields, ride.FieldDurationMinutes)
	}
	if m.FieldCleared(ride.FieldOriginLocationPoint) {
		fields = append(fields, ride.FieldOriginLocationPoint)
	}
	if m.FieldCleared(ride.FieldDestinationLocationPoint) {
		fields = append(fields, ride.FieldDestinationLocationPoint)
	}
	if m.FieldCleared(ride.FieldAmenities) {
		fields = append(fields, ride.FieldAmenities)
	}
	if m.FieldCleared(ride.FieldStops) {
		fields = append(fields, ride.FieldStops)
	}
	if m.FieldCleared(ride.FieldDescription) {
		fields = append(fields, ride.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RideMutation) ClearField(name string) error {
	switch name {
	case ride.FieldVehicleID:
		m.ClearVehicleID()
		return nil
	case ride.FieldRecurrence:
		m.ClearRecurrence()
		return nil
	case ride.FieldArrivalTime:
		m.ClearArrivalTime()
		return nil
	case ride.FieldDurationMinutes:
		m.ClearDurationMinutes()
		return nil
	case ride.FieldOriginLocationPoint:
		m.ClearOriginLocationPoint()
		return nil
	case ride.FieldDestinationLocationPoint:
		m.ClearDestinationLocationPoint()
		return nil
	case ride.FieldAmenities:
		m.ClearAmenities()
		return nil
	case ride.FieldStops:
		m.ClearStops()
		return nil
	case ride.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Ride nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RideMutation) ResetField(name string) error {
	switch name {
	case ride.FieldDriverID:
		m.ResetDriverID()
		return nil
	case ride.FieldVehicleID:
		m.ResetVehicleID()
		return nil
	case ride.FieldType:
		m.ResetType()
		return nil
	case ride.FieldRideType:
		m.ResetRideType()
		return nil
	case ride.FieldRecurrence:
		m.ResetRecurrence()
		return nil
	case ride.FieldDepartureTime:
		m.ResetDepartureTime()
		return nil
	case ride.FieldArrivalTime:
		m.ResetArrivalTime()
		return nil
	case ride.FieldDurationMinutes:
		m.ResetDurationMinutes()
		return nil
	case ride.FieldOriginCity:
		m.ResetOriginCity()
		return nil
	case ride.FieldOriginAddress:
		m.ResetOriginAddress()
		return nil
	case ride.FieldOriginLocationPoint:
		m.ResetOriginLocationPoint()
		return nil
	case ride.FieldDestinationCity:
		m.ResetDestinationCity()
		return nil
	case ride.FieldDestinationAddress:
		m.ResetDestinationAddress()
		return nil
	case ride.FieldDestinationLocationPoint:
		m.ResetDestinationLocationPoint()
		return nil
	case ride.FieldPriceAmount:
		m.ResetPriceAmount()
		return nil
	case ride.FieldPriceCurrency:
		m.ResetPriceCurrency()
		return nil
	case ride.FieldAvailableSeats:
		m.ResetAvailableSeats()
		return nil
	case ride.FieldTotalSeats:
		m.ResetTotalSeats()
		return nil
	case ride.FieldAmenities:
		m.ResetAmenities()
		return nil
	case ride.FieldStops:
		m.ResetStops()
		return nil
	case ride.FieldInstantConfirmation:
		m.ResetInstantConfirmation()
		return nil
	case ride.FieldCancellationPolicy:
		m.ResetCancellationPolicy()
		return nil
	case ride.FieldDescription:
		m.ResetDescription()
		return nil
	case ride.FieldStatus:
		m.ResetStatus()
		return nil
	case ride.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ride.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ride field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RideMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._driver != nil {
		edges = append(edges, ride.EdgeDriver)
	}
	if m.vehicle != nil {
		edges = append(edges, ride.EdgeVehicle)
	}
	if m.bookings != nil {
		edges = append(edges, ride.EdgeBookings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ride.EdgeDriver:
		if id := m._driver; id != nil {
			return []ent.Value{*id}
		}
	case ride.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	case ride.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbookings != nil {
		edges = append(edges, ride.EdgeBookings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RideMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ride.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_driver {
		edges = append(edges, ride.EdgeDriver)
	}
	if m.clearedvehicle {
		edges = append(edges, ride.EdgeVehicle)
	}
	if m.clearedbookings {
		edges = append(edges, ride.EdgeBookings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RideMutation) EdgeCleared(name string) bool {
	switch name {
	case ride.EdgeDriver:
		return m.cleared_driver
	case ride.EdgeVehicle:
		return m.clearedvehicle
	case ride.EdgeBookings:
		return m.clearedbookings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RideMutation) ClearEdge(name string) error {
	switch name {
	case ride.EdgeDriver:
		m.ClearDriver()
		return nil
	case ride.EdgeVehicle:
		m.ClearVehicle()
		return nil
	}
	return fmt.Errorf("unknown Ride unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RideMutation) ResetEdge(name string) error {
	switch name {
	case ride.EdgeDriver:
		m.ResetDriver()
		return nil
	case ride.EdgeVehicle:
		m.ResetVehicle()
		return nil
	case ride.EdgeBookings:
		m.ResetBookings()
		return nil
	}
	return fmt.Errorf("unknown Ride edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	email               *string
	phone               *string
	password_hash       *string
	age                 *int
	addage              *int
	experience_level    *string
	rating              *float64
	addrating           *float64
	rating_count        *int
	addrating_count     *int
	driving_rating      *string
	profile_picture_url *string
	is_verified         *bool
	verified_id         *bool
	confirmed_email     *bool
	confirmed_phone     *bool
	bio                 *string
	preferences         *map[string]interface{}
	membership_type     *string
	published_rides     *int
	addpublished_rides  *int
	completed_rides     *int
	addcompleted_rides  *int
	never_cancels       *bool
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	rides               map[string]struct{}
	removedrides        map[string]struct{}
	clearedrides        bool
	bookings            map[string]struct{}
	removedbookings     map[string]struct{}
	clearedbookings     bool
	vehicles            map[string]struct{}
	removedvehicles     map[string]struct{}
	clearedvehicles     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetAge sets the "age" field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of the "age" field.
func (m *UserMutation) ClearAge() {
	m.age = nil
	m.addage = nil
	m.clearedFields[user.FieldAge] = struct{}{}
}

// AgeCleared returns if the "age" field was cleared in this mutation.
func (m *UserMutation) AgeCleared() bool {
	_, ok := m.clearedFields[user.FieldAge]
	return ok
}

// ResetAge resets all changes to the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
	delete(m.clearedFields, user.FieldAge)
}

// SetExperienceLevel sets the "experience_level" field.
func (m *UserMutation) SetExperienceLevel(s string) {
	m.experience_level = &s
}

// ExperienceLevel returns the value of the "experience_level" field in the mutation.
func (m *UserMutation) ExperienceLevel() (r string, exists bool) {
	v := m.experience_level
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceLevel returns the old "experience_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExperienceLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceLevel: %w", err)
	}
	return oldValue.ExperienceLevel, nil
}

// ResetExperienceLevel resets all changes to the "experience_level" field.
func (m *UserMutation) ResetExperienceLevel() {
	m.experience_level = nil
}

// SetRating sets the "rating" field.
func (m *UserMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *UserMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *UserMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *UserMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *UserMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *UserMutation) SetRatingCount(i int) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *UserMutation) RatingCount() (r int, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRatingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *UserMutation) AddRatingCount(i int) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *UserMutation) AddedRatingCount() (r int, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *UserMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// SetDrivingRating sets the "driving_rating" field.
func (m *UserMutation) SetDrivingRating(s string) {
	m.driving_rating = &s
}

// DrivingRating returns the value of the "driving_rating" field in the mutation.
func (m *UserMutation) DrivingRating() (r string, exists bool) {
	v := m.driving_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingRating returns the old "driving_rating" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDrivingRating(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingRating: %w", err)
	}
	return oldValue.DrivingRating, nil
}

// ClearDrivingRating clears the value of the "driving_rating" field.
func (m *UserMutation) ClearDrivingRating() {
	m.driving_rating = nil
	m.clearedFields[user.FieldDrivingRating] = struct{}{}
}

// DrivingRatingCleared returns if the "driving_rating" field was cleared in this mutation.
func (m *UserMutation) DrivingRatingCleared() bool {
	_, ok := m.clearedFields[user.FieldDrivingRating]
	return ok
}

// ResetDrivingRating resets all changes to the "driving_rating" field.
func (m *UserMutation) ResetDrivingRating() {
	m.driving_rating = nil
	delete(m.clearedFields, user.FieldDrivingRating)
}

// SetProfilePictureURL sets the "profile_picture_url" field.
func (m *UserMutation) SetProfilePictureURL(s string) {
	m.profile_picture_url = &s
}

// ProfilePictureURL returns the value of the "profile_picture_url" field in the mutation.
func (m *UserMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePictureURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_url" field.
func (m *UserMutation) ClearProfilePictureURL() {
	m.profile_picture_url = nil
	m.clearedFields[user.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_url" field was cleared in this mutation.
func (m *UserMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_url" field.
func (m *UserMutation) ResetProfilePictureURL() {
	m.profile_picture_url = nil
	delete(m.clearedFields, user.FieldProfilePictureURL)
}

// SetIsVerified sets the "is_verified" field.
func (m *UserMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetVerifiedID sets the "verified_id" field.
func (m *UserMutation) SetVerifiedID(b bool) {
	m.verified_id = &b
}

// VerifiedID returns the value of the "verified_id" field in the mutation.
func (m *UserMutation) VerifiedID() (r bool, exists bool) {
	v := m.verified_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedID returns the old "verified_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerifiedID(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedID: %w", err)
	}
	return oldValue.VerifiedID, nil
}

// ResetVerifiedID resets all changes to the "verified_id" field.
func (m *UserMutation) ResetVerifiedID() {
	m.verified_id = nil
}

// SetConfirmedEmail sets the "confirmed_email" field.
func (m *UserMutation) SetConfirmedEmail(b bool) {
	m.confirmed_email = &b
}

// ConfirmedEmail returns the value of the "confirmed_email" field in the mutation.
func (m *UserMutation) ConfirmedEmail() (r bool, exists bool) {
	v := m.confirmed_email
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedEmail returns the old "confirmed_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConfirmedEmail(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedEmail: %w", err)
	}
	return oldValue.ConfirmedEmail, nil
}

// ResetConfirmedEmail resets all changes to the "confirmed_email" field.
func (m *UserMutation) ResetConfirmedEmail() {
	m.confirmed_email = nil
}

// SetConfirmedPhone sets the "confirmed_phone" field.
func (m *UserMutation) SetConfirmedPhone(b bool) {
	m.confirmed_phone = &b
}

// ConfirmedPhone returns the value of the "confirmed_phone" field in the mutation.
func (m *UserMutation) ConfirmedPhone() (r bool, exists bool) {
	v := m.confirmed_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedPhone returns the old "confirmed_phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConfirmedPhone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedPhone: %w", err)
	}
	return oldValue.ConfirmedPhone, nil
}

// ResetConfirmedPhone resets all changes to the "confirmed_phone" field.
func (m *UserMutation) ResetConfirmedPhone() {
	m.confirmed_phone = nil
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetPreferences sets the "preferences" field.
func (m *UserMutation) SetPreferences(value map[string]interface{}) {
	m.preferences = &value
}

// Preferences returns the value of the "preferences" field in the mutation.
func (m *UserMutation) Preferences() (r map[string]interface{}, exists bool) {
	v := m.preferences
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferences returns the old "preferences" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPreferences(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferences: %w", err)
	}
	return oldValue.Preferences, nil
}

// ClearPreferences clears the value of the "preferences" field.
func (m *UserMutation) ClearPreferences() {
	m.preferences = nil
	m.clearedFields[user.FieldPreferences] = struct{}{}
}

// PreferencesCleared returns if the "preferences" field was cleared in this mutation.
func (m *UserMutation) PreferencesCleared() bool {
	_, ok := m.clearedFields[user.FieldPreferences]
	return ok
}

// ResetPreferences resets all changes to the "preferences" field.
func (m *UserMutation) ResetPreferences() {
	m.preferences = nil
	delete(m.clearedFields, user.FieldPreferences)
}

// SetMembershipType sets the "membership_type" field.
func (m *UserMutation) SetMembershipType(s string) {
	m.membership_type = &s
}

// MembershipType returns the value of the "membership_type" field in the mutation.
func (m *UserMutation) MembershipType() (r string, exists bool) {
	v := m.membership_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMembershipType returns the old "membership_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMembershipType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembershipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembershipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembershipType: %w", err)
	}
	return oldValue.MembershipType, nil
}

// ResetMembershipType resets all changes to the "membership_type" field.
func (m *UserMutation) ResetMembershipType() {
	m.membership_type = nil
}

// SetPublishedRides sets the "published_rides" field.
func (m *UserMutation) SetPublishedRides(i int) {
	m.published_rides = &i
	m.addpublished_rides = nil
}

// PublishedRides returns the value of the "published_rides" field in the mutation.
func (m *UserMutation) PublishedRides() (r int, exists bool) {
	v := m.published_rides
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedRides returns the old "published_rides" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublishedRides(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedRides is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedRides requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedRides: %w", err)
	}
	return oldValue.PublishedRides, nil
}

// AddPublishedRides adds i to the "published_rides" field.
func (m *UserMutation) AddPublishedRides(i int) {
	if m.addpublished_rides != nil {
		*m.addpublished_rides += i
	} else {
		m.addpublished_rides = &i
	}
}

// AddedPublishedRides returns the value that was added to the "published_rides" field in this mutation.
func (m *UserMutation) AddedPublishedRides() (r int, exists bool) {
	v := m.addpublished_rides
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublishedRides resets all changes to the "published_rides" field.
func (m *UserMutation) ResetPublishedRides() {
	m.published_rides = nil
	m.addpublished_rides = nil
}

// SetCompletedRides sets the "completed_rides" field.
func (m *UserMutation) SetCompletedRides(i int) {
	m.completed_rides = &i
	m.addcompleted_rides = nil
}

// CompletedRides returns the value of the "completed_rides" field in the mutation.
func (m *UserMutation) CompletedRides() (r int, exists bool) {
	v := m.completed_rides
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedRides returns the old "completed_rides" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompletedRides(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedRides is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedRides requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedRides: %w", err)
	}
	return oldValue.CompletedRides, nil
}

// AddCompletedRides adds i to the "completed_rides" field.
func (m *UserMutation) AddCompletedRides(i int) {
	if m.addcompleted_rides != nil {
		*m.addcompleted_rides += i
	} else {
		m.addcompleted_rides = &i
	}
}

// AddedCompletedRides returns the value that was added to the "completed_rides" field in this mutation.
func (m *UserMutation) AddedCompletedRides() (r int, exists bool) {
	v := m.addcompleted_rides
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletedRides resets all changes to the "completed_rides" field.
func (m *UserMutation) ResetCompletedRides() {
	m.completed_rides = nil
	m.addcompleted_rides = nil
}

// SetNeverCancels sets the "never_cancels" field.
func (m *UserMutation) SetNeverCancels(b bool) {
	m.never_cancels = &b
}

// NeverCancels returns the value of the "never_cancels" field in the mutation.
func (m *UserMutation) NeverCancels() (r bool, exists bool) {
	v := m.never_cancels
	if v == nil {
		return
	}
	return *v, true
}

// OldNeverCancels returns the old "never_cancels" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNeverCancels(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeverCancels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeverCancels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeverCancels: %w", err)
	}
	return oldValue.NeverCancels, nil
}

// ResetNeverCancels resets all changes to the "never_cancels" field.
func (m *UserMutation) ResetNeverCancels() {
	m.never_cancels = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRideIDs adds the "rides" edge to the Ride entity by ids.
func (m *UserMutation) AddRideIDs(ids ...string) {
	if m.rides == nil {
		m.rides = make(map[string]struct{})
	}
	for i := range ids {
		m.rides[ids[i]] = struct{}{}
	}
}

// ClearRides clears the "rides" edge to the Ride entity.
func (m *UserMutation) ClearRides() {
	m.clearedrides = true
}

// RidesCleared reports if the "rides" edge to the Ride entity was cleared.
func (m *UserMutation) RidesCleared() bool {
	return m.clearedrides
}

// RemoveRideIDs removes the "rides" edge to the Ride entity by IDs.
func (m *UserMutation) RemoveRideIDs(ids ...string) {
	if m.removedrides == nil {
		m.removedrides = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rides, ids[i])
		m.removedrides[ids[i]] = struct{}{}
	}
}

// RemovedRides returns the removed IDs of the "rides" edge to the Ride entity.
func (m *UserMutation) RemovedRidesIDs() (ids []string) {
	for id := range m.removedrides {
		ids = append(ids, id)
	}
	return
}

// RidesIDs returns the "rides" edge IDs in the mutation.
func (m *UserMutation) RidesIDs() (ids []string) {
	for id := range m.rides {
		ids = append(ids, id)
	}
	return
}

// ResetRides resets all changes to the "rides" edge.
func (m *UserMutation) ResetRides() {
	m.rides = nil
	m.clearedrides = false
	m.removedrides = nil
}

// AddBookingIDs adds the "bookings" edge to the Booking entity by ids.
func (m *UserMutation) AddBookingIDs(ids ...string) {
	if m.bookings == nil {
		m.bookings = make(map[string]struct{})
	}
	for i := range ids {
		m.bookings[ids[i]] = struct{}{}
	}
}

// ClearBookings clears the "bookings" edge to the Booking entity.
func (m *UserMutation) ClearBookings() {
	m.clearedbookings = true
}

// BookingsCleared reports if the "bookings" edge to the Booking entity was cleared.
func (m *UserMutation) BookingsCleared() bool {
	return m.clearedbookings
}

// RemoveBookingIDs removes the "bookings" edge to the Booking entity by IDs.
func (m *UserMutation) RemoveBookingIDs(ids ...string) {
	if m.removedbookings == nil {
		m.removedbookings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.bookings, ids[i])
		m.removedbookings[ids[i]] = struct{}{}
	}
}

// RemovedBookings returns the removed IDs of the "bookings" edge to the Booking entity.
func (m *UserMutation) RemovedBookingsIDs() (ids []string) {
	for id := range m.removedbookings {
		ids = append(ids, id)
	}
	return
}

// BookingsIDs returns the "bookings" edge IDs in the mutation.
func (m *UserMutation) BookingsIDs() (ids []string) {
	for id := range m.bookings {
		ids = append(ids, id)
	}
	return
}

// ResetBookings resets all changes to the "bookings" edge.
func (m *UserMutation) ResetBookings() {
	m.bookings = nil
	m.clearedbookings = false
	m.removedbookings = nil
}

// AddVehicleIDs adds the "vehicles" edge to the Vehicle entity by ids.
func (m *UserMutation) AddVehicleIDs(ids ...string) {
	if m.vehicles == nil {
		m.vehicles = make(map[string]struct{})
	}
	for i := range ids {
		m.vehicles[ids[i]] = struct{}{}
	}
}

// ClearVehicles clears the "vehicles" edge to the Vehicle entity.
func (m *UserMutation) ClearVehicles() {
	m.clearedvehicles = true
}

// VehiclesCleared reports if the "vehicles" edge to the Vehicle entity was cleared.
func (m *UserMutation) VehiclesCleared() bool {
	return m.clearedvehicles
}

// RemoveVehicleIDs removes the "vehicles" edge to the Vehicle entity by IDs.
func (m *UserMutation) RemoveVehicleIDs(ids ...string) {
	if m.removedvehicles == nil {
		m.removedvehicles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vehicles, ids[i])
		m.removedvehicles[ids[i]] = struct{}{}
	}
}

// RemovedVehicles returns the removed IDs of the "vehicles" edge to the Vehicle entity.
func (m *UserMutation) RemovedVehiclesIDs() (ids []string) {
	for id := range m.removedvehicles {
		ids = append(ids, id)
	}
	return
}

// VehiclesIDs returns the "vehicles" edge IDs in the mutation.
func (m *UserMutation) VehiclesIDs() (ids []string) {
	for id := range m.vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetVehicles resets all changes to the "vehicles" edge.
func (m *UserMutation) ResetVehicles() {
	m.vehicles = nil
	m.clearedvehicles = false
	m.removedvehicles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.experience_level != nil {
		fields = append(fields, user.FieldExperienceLevel)
	}
	if m.rating != nil {
		fields = append(fields, user.FieldRating)
	}
	if m.rating_count != nil {
		fields = append(fields, user.FieldRatingCount)
	}
	if m.driving_rating != nil {
		fields = append(fields, user.FieldDrivingRating)
	}
	if m.profile_picture_url != nil {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	if m.is_verified != nil {
		fields = append(fields, user.FieldIsVerified)
	}
	if m.verified_id != nil {
		fields = append(fields, user.FieldVerifiedID)
	}
	if m.confirmed_email != nil {
		fields = append(fields, user.FieldConfirmedEmail)
	}
	if m.confirmed_phone != nil {
		fields = append(fields, user.FieldConfirmedPhone)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.preferences != nil {
		fields = append(fields, user.FieldPreferences)
	}
	if m.membership_type != nil {
		fields = append(fields, user.FieldMembershipType)
	}
	if m.published_rides != nil {
		fields = append(fields, user.FieldPublishedRides)
	}
	if m.completed_rides != nil {
		fields = append(fields, user.FieldCompletedRides)
	}
	if m.never_cancels != nil {
		fields = append(fields, user.FieldNeverCancels)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldAge:
		return m.Age()
	case user.FieldExperienceLevel:
		return m.ExperienceLevel()
	case user.FieldRating:
		return m.Rating()
	case user.FieldRatingCount:
		return m.RatingCount()
	case user.FieldDrivingRating:
		return m.DrivingRating()
	case user.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	case user.FieldIsVerified:
		return m.IsVerified()
	case user.FieldVerifiedID:
		return m.VerifiedID()
	case user.FieldConfirmedEmail:
		return m.ConfirmedEmail()
	case user.FieldConfirmedPhone:
		return m.ConfirmedPhone()
	case user.FieldBio:
		return m.Bio()
	case user.FieldPreferences:
		return m.Preferences()
	case user.FieldMembershipType:
		return m.MembershipType()
	case user.FieldPublishedRides:
		return m.PublishedRides()
	case user.FieldCompletedRides:
		return m.CompletedRides()
	case user.FieldNeverCancels:
		return m.NeverCancels()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldExperienceLevel:
		return m.OldExperienceLevel(ctx)
	case user.FieldRating:
		return m.OldRating(ctx)
	case user.FieldRatingCount:
		return m.OldRatingCount(ctx)
	case user.FieldDrivingRating:
		return m.OldDrivingRating(ctx)
	case user.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	case user.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case user.FieldVerifiedID:
		return m.OldVerifiedID(ctx)
	case user.FieldConfirmedEmail:
		return m.OldConfirmedEmail(ctx)
	case user.FieldConfirmedPhone:
		return m.OldConfirmedPhone(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldPreferences:
		return m.OldPreferences(ctx)
	case user.FieldMembershipType:
		return m.OldMembershipType(ctx)
	case user.FieldPublishedRides:
		return m.OldPublishedRides(ctx)
	case user.FieldCompletedRides:
		return m.OldCompletedRides(ctx)
	case user.FieldNeverCancels:
		return m.OldNeverCancels(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldExperienceLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceLevel(v)
		return nil
	case user.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case user.FieldRatingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	case user.FieldDrivingRating:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingRating(v)
		return nil
	case user.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	case user.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case user.FieldVerifiedID:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedID(v)
		return nil
	case user.FieldConfirmedEmail:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedEmail(v)
		return nil
	case user.FieldConfirmedPhone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedPhone(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldPreferences:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferences(v)
		return nil
	case user.FieldMembershipType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembershipType(v)
		return nil
	case user.FieldPublishedRides:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedRides(v)
		return nil
	case user.FieldCompletedRides:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedRides(v)
		return nil
	case user.FieldNeverCancels:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeverCancels(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.addrating != nil {
		fields = append(fields, user.FieldRating)
	}
	if m.addrating_count != nil {
		fields = append(fields, user.FieldRatingCount)
	}
	if m.addpublished_rides != nil {
		fields = append(fields, user.FieldPublishedRides)
	}
	if m.addcompleted_rides != nil {
		fields = append(fields, user.FieldCompletedRides)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.AddedAge()
	case user.FieldRating:
		return m.AddedRating()
	case user.FieldRatingCount:
		return m.AddedRatingCount()
	case user.FieldPublishedRides:
		return m.AddedPublishedRides()
	case user.FieldCompletedRides:
		return m.AddedCompletedRides()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case user.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case user.FieldRatingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	case user.FieldPublishedRides:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublishedRides(v)
		return nil
	case user.FieldCompletedRides:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletedRides(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldAge) {
		fields = append(fields, user.FieldAge)
	}
	if m.FieldCleared(user.FieldDrivingRating) {
		fields = append(fields, user.FieldDrivingRating)
	}
	if m.FieldCleared(user.FieldProfilePictureURL) {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldPreferences) {
		fields = append(fields, user.FieldPreferences)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldAge:
		m.ClearAge()
		return nil
	case user.FieldDrivingRating:
		m.ClearDrivingRating()
		return nil
	case user.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldPreferences:
		m.ClearPreferences()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldExperienceLevel:
		m.ResetExperienceLevel()
		return nil
	case user.FieldRating:
		m.ResetRating()
		return nil
	case user.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	case user.FieldDrivingRating:
		m.ResetDrivingRating()
		return nil
	case user.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	case user.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case user.FieldVerifiedID:
		m.ResetVerifiedID()
		return nil
	case user.FieldConfirmedEmail:
		m.ResetConfirmedEmail()
		return nil
	case user.FieldConfirmedPhone:
		m.ResetConfirmedPhone()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldPreferences:
		m.ResetPreferences()
		return nil
	case user.FieldMembershipType:
		m.ResetMembershipType()
		return nil
	case user.FieldPublishedRides:
		m.ResetPublishedRides()
		return nil
	case user.FieldCompletedRides:
		m.ResetCompletedRides()
		return nil
	case user.FieldNeverCancels:
		m.ResetNeverCancels()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.rides != nil {
		edges = append(edges, user.EdgeRides)
	}
	if m.bookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	if m.vehicles != nil {
		edges = append(edges, user.EdgeVehicles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRides:
		ids := make([]ent.Value, 0, len(m.rides))
		for id := range m.rides {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.bookings))
		for id := range m.bookings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.vehicles))
		for id := range m.vehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrides != nil {
		edges = append(edges, user.EdgeRides)
	}
	if m.removedbookings != nil {
		edges = append(edges, user.EdgeBookings)
	}
	if m.removedvehicles != nil {
		edges = append(edges, user.EdgeVehicles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRides:
		ids := make([]ent.Value, 0, len(m.removedrides))
		for id := range m.removedrides {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookings:
		ids := make([]ent.Value, 0, len(m.removedbookings))
		for id := range m.removedbookings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.removedvehicles))
		for id := range m.removedvehicles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrides {
		edges = append(edges, user.EdgeRides)
	}
	if m.clearedbookings {
		edges = append(edges, user.EdgeBookings)
	}
	if m.clearedvehicles {
		edges = append(edges, user.EdgeVehicles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRides:
		return m.clearedrides
	case user.EdgeBookings:
		return m.clearedbookings
	case user.EdgeVehicles:
		return m.clearedvehicles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRides:
		m.ResetRides()
		return nil
	case user.EdgeBookings:
		m.ResetBookings()
		return nil
	case user.EdgeVehicles:
		m.ResetVehicles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op            Op
	typ           string
	id            *string
	make          *string
	model         *string
	color         *string
	license_plate *string
	year          *int
	addyear       *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	rides         map[string]struct{}
	removedrides  map[string]struct{}
	clearedrides  bool
	done          bool
	oldValue      func(context.Context) (*Vehicle, error)
	predicates    []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id string) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vehicle entities.
func (m *VehicleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vehicle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *VehicleMutation) SetUserID(s string) {
	m.owner = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *VehicleMutation) UserID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *VehicleMutation) ResetUserID() {
	m.owner = nil
}

// SetMake sets the "make" field.
func (m *VehicleMutation) SetMake(s string) {
	m.make = &s
}

// Make returns the value of the "make" field in the mutation.
func (m *VehicleMutation) Make() (r string, exists bool) {
	v := m.make
	if v == nil {
		return
	}
	return *v, true
}

// OldMake returns the old "make" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldMake(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMake: %w", err)
	}
	return oldValue.Make, nil
}

// ResetMake resets all changes to the "make" field.
func (m *VehicleMutation) ResetMake() {
	m.make = nil
}

// SetModel sets the "model" field.
func (m *VehicleMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *VehicleMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *VehicleMutation) ResetModel() {
	m.model = nil
}

// SetColor sets the "color" field.
func (m *VehicleMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *VehicleMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *VehicleMutation) ResetColor() {
	m.color = nil
}

// SetLicensePlate sets the "license_plate" field.
func (m *VehicleMutation) SetLicensePlate(s string) {
	m.license_plate = &s
}

// LicensePlate returns the value of the "license_plate" field in the mutation.
func (m *VehicleMutation) LicensePlate() (r string, exists bool) {
	v := m.license_plate
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensePlate returns the old "license_plate" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldLicensePlate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicensePlate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicensePlate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensePlate: %w", err)
	}
	return oldValue.LicensePlate, nil
}

// ClearLicensePlate clears the value of the "license_plate" field.
func (m *VehicleMutation) ClearLicensePlate() {
	m.license_plate = nil
	m.clearedFields[vehicle.FieldLicensePlate] = struct{}{}
}

// LicensePlateCleared returns if the "license_plate" field was cleared in this mutation.
func (m *VehicleMutation) LicensePlateCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldLicensePlate]
	return ok
}

// ResetLicensePlate resets all changes to the "license_plate" field.
func (m *VehicleMutation) ResetLicensePlate() {
	m.license_plate = nil
	delete(m.clearedFields, vehicle.FieldLicensePlate)
}

// SetYear sets the "year" field.
func (m *VehicleMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *VehicleMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *VehicleMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *VehicleMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *VehicleMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[vehicle.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *VehicleMutation) YearCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *VehicleMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, vehicle.FieldYear)
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *VehicleMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *VehicleMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[vehicle.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *VehicleMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *VehicleMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *VehicleMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddRideIDs adds the "rides" edge to the Ride entity by ids.
func (m *VehicleMutation) AddRideIDs(ids ...string) {
	if m.rides == nil {
		m.rides = make(map[string]struct{})
	}
	for i := range ids {
		m.rides[ids[i]] = struct{}{}
	}
}

// ClearRides clears the "rides" edge to the Ride entity.
func (m *VehicleMutation) ClearRides() {
	m.clearedrides = true
}

// RidesCleared reports if the "rides" edge to the Ride entity was cleared.
func (m *VehicleMutation) RidesCleared() bool {
	return m.clearedrides
}

// RemoveRideIDs removes the "rides" edge to the Ride entity by IDs.
func (m *VehicleMutation) RemoveRideIDs(ids ...string) {
	if m.removedrides == nil {
		m.removedrides = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rides, ids[i])
		m.removedrides[ids[i]] = struct{}{}
	}
}

// RemovedRides returns the removed IDs of the "rides" edge to the Ride entity.
func (m *VehicleMutation) RemovedRidesIDs() (ids []string) {
	for id := range m.removedrides {
		ids = append(ids, id)
	}
	return
}

// RidesIDs returns the "rides" edge IDs in the mutation.
func (m *VehicleMutation) RidesIDs() (ids []string) {
	for id := range m.rides {
		ids = append(ids, id)
	}
	return
}

// ResetRides resets all changes to the "rides" edge.
func (m *VehicleMutation) ResetRides() {
	m.rides = nil
	m.clearedrides = false
	m.removedrides = nil
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vehicle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.owner != nil {
		fields = append(fields, vehicle.FieldUserID)
	}
	if m.make != nil {
		fields = append(fields, vehicle.FieldMake)
	}
	if m.model != nil {
		fields = append(fields, vehicle.FieldModel)
	}
	if m.color != nil {
		fields = append(fields, vehicle.FieldColor)
	}
	if m.license_plate != nil {
		fields = append(fields, vehicle.FieldLicensePlate)
	}
	if m.year != nil {
		fields = append(fields, vehicle.FieldYear)
	}
	if m.created_at != nil {
		fields = append(fields, vehicle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicle.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldUserID:
		return m.UserID()
	case vehicle.FieldMake:
		return m.Make()
	case vehicle.FieldModel:
		return m.Model()
	case vehicle.FieldColor:
		return m.Color()
	case vehicle.FieldLicensePlate:
		return m.LicensePlate()
	case vehicle.FieldYear:
		return m.Year()
	case vehicle.FieldCreatedAt:
		return m.CreatedAt()
	case vehicle.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldUserID:
		return m.OldUserID(ctx)
	case vehicle.FieldMake:
		return m.OldMake(ctx)
	case vehicle.FieldModel:
		return m.OldModel(ctx)
	case vehicle.FieldColor:
		return m.OldColor(ctx)
	case vehicle.FieldLicensePlate:
		return m.OldLicensePlate(ctx)
	case vehicle.FieldYear:
		return m.OldYear(ctx)
	case vehicle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case vehicle.FieldMake:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMake(v)
		return nil
	case vehicle.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case vehicle.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case vehicle.FieldLicensePlate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensePlate(v)
		return nil
	case vehicle.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case vehicle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, vehicle.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicle.FieldLicensePlate) {
		fields = append(fields, vehicle.FieldLicensePlate)
	}
	if m.FieldCleared(vehicle.FieldYear) {
		fields = append(fields, vehicle.FieldYear)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	switch name {
	case vehicle.FieldLicensePlate:
		m.ClearLicensePlate()
		return nil
	case vehicle.FieldYear:
		m.ClearYear()
		return nil
	}
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldUserID:
		m.ResetUserID()
		return nil
	case vehicle.FieldMake:
		m.ResetMake()
		return nil
	case vehicle.FieldModel:
		m.ResetModel()
		return nil
	case vehicle.FieldColor:
		m.ResetColor()
		return nil
	case vehicle.FieldLicensePlate:
		m.ResetLicensePlate()
		return nil
	case vehicle.FieldYear:
		m.ResetYear()
		return nil
	case vehicle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, vehicle.EdgeOwner)
	}
	if m.rides != nil {
		edges = append(edges, vehicle.EdgeRides)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeRides:
		ids := make([]ent.Value, 0, len(m.rides))
		for id := range m.rides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrides != nil {
		edges = append(edges, vehicle.EdgeRides)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeRides:
		ids := make([]ent.Value, 0, len(m.removedrides))
		for id := range m.removedrides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, vehicle.EdgeOwner)
	}
	if m.clearedrides {
		edges = append(edges, vehicle.EdgeRides)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicle.EdgeOwner:
		return m.clearedowner
	case vehicle.EdgeRides:
		return m.clearedrides
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	switch name {
	case vehicle.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	switch name {
	case vehicle.EdgeOwner:
		m.ResetOwner()
		return nil
	case vehicle.EdgeRides:
		m.ResetRides()
		return nil
	}
	return fmt.Errorf("unknown Vehicle edge %s", name)
}
